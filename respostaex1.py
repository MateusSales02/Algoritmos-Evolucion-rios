# -*- coding: utf-8 -*-
"""respostaEx1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wKst-jEkqx31J8uvxk7-sDpF44wQ4gMl
"""

import random

# Função para inicializar a população com strings binárias aleatórias
def inicializar_populacao(tamanho_populacao, tamanho_problema):
    return [[random.randint(0, 1) for _ in range(tamanho_problema)] for _ in range(tamanho_populacao)]

# Função de fitness que avalia a quantidade de "1s" em um indivíduo
def fitness(individuo):
    return sum(individuo)

# Função para selecionar os melhores pais com base na aptidão
def selecionar_pais(populacao):
    avaliacoes = [fitness(individuo) for individuo in populacao]
    total = sum(avaliacoes)
    probabilidades = [avaliacao / total for avaliacao in avaliacoes]
    pais = random.choices(populacao, weights=probabilidades, k=len(populacao))
    return pais

# Função de cruzamento que combina dois pais para gerar filhos
def cruzamento(pai1, pai2, pcrossover):
    if random.random() < pcrossover:
        ponto = random.randint(1, len(pai1) - 1)
        filho1 = pai1[:ponto] + pai2[ponto:]
        filho2 = pai2[:ponto] + pai1[ponto:]
        return filho1, filho2
    return pai1, pai2  # Sem cruzamento

# Função de mutação que altera bits aleatórios em um indivíduo
def mutar(individuo, pmutacao):
    return [gene if random.random() > pmutacao else 1 - gene for gene in individuo]

# Função para substituir a população antiga pelos filhos
def substituir(populacao, filhos):
    return filhos

# Função principal do Algoritmo Genético
def algoritmo_genetico(tamanho_populacao, tamanho_problema, pcrossover, pmutacao, max_geracoes=100):
    populacao = inicializar_populacao(tamanho_populacao, tamanho_problema)
    melhor_solucao_geracao = None
    melhor_fitness_geracao = 0
    melhor_geracao = 0

    for geracao in range(max_geracoes):
        pais = selecionar_pais(populacao)
        filhos = []

        # Cruzamento e mutação
        for i in range(0, len(pais), 2):
            pai1 = pais[i]
            pai2 = pais[i + 1] if i + 1 < len(pais) else pais[0]
            filho1, filho2 = cruzamento(pai1, pai2, pcrossover)
            filhos.append(mutar(filho1, pmutacao))
            filhos.append(mutar(filho2, pmutacao))

        populacao = substituir(populacao, filhos)

        # Avalia a melhor solução desta geração
        melhor_solucao = max(populacao, key=fitness)
        melhor_fitness = fitness(melhor_solucao)

        print(f"Geração {geracao + 1}: Melhor solução = {melhor_solucao}, Fitness = {melhor_fitness}")

        # Armazena a melhor geração e a melhor solução
        if melhor_fitness > melhor_fitness_geracao:
            melhor_fitness_geracao = melhor_fitness
            melhor_solucao_geracao = melhor_solucao
            melhor_geracao = geracao + 1

    print(f"\nA melhor geração foi a {melhor_geracao}, com a solução {melhor_solucao_geracao} e fitness {melhor_fitness_geracao}")

# Exemplo de uso
tamanho_populacao = 10
tamanho_problema = 20
pcrossover = 0.7
pmutacao = 0.01

algoritmo_genetico(tamanho_populacao, tamanho_problema, pcrossover, pmutacao)